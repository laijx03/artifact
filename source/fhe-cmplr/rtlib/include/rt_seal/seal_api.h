//-*-c-*-
//=============================================================================
//
// Copyright (c) XXXX-XXXX., Ltd
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//=============================================================================

#ifndef RTLIB_RT_SEAL_SEAL_API_H
#define RTLIB_RT_SEAL_SEAL_API_H

//! @brief seal_api.h
//! Define seal API can be used by rtlib

#include <seal/seal.h>

#include "common/tensor.h"
#include "rt_def.h"

typedef double              SCALE_T;
typedef seal::parms_id_type LEVEL_T;

#ifdef __cplusplus
extern "C" {
#endif

//! @brief Seal API for context management
void       Seal_prepare_input(TENSOR* input, const char* name);
void       Seal_set_output_data(const char* name, size_t idx, CIPHER data);
CIPHERTEXT Seal_get_input_data(const char* name, size_t idx);
void Seal_encode_float(PLAIN plain, float* input, size_t len, SCALE_T scale,
                       LEVEL_T level);
void Seal_encode_double(PLAIN plain, double* input, size_t len, SCALE_T scale,
                        LEVEL_T level);
void Seal_encode_float_cst_lvl(PLAIN plain, float* input, size_t len,
                               SCALE_T scale, int level);
void Seal_encode_double_cst_lvl(PLAIN plain, double* input, size_t len,
                                SCALE_T scale, int level);
void Seal_encode_float_mask(PLAIN plain, float input, size_t len, SCALE_T scale,
                            LEVEL_T level);
void Seal_encode_double_mask(PLAIN plain, double input, size_t len,
                             SCALE_T scale, LEVEL_T level);
void Seal_encode_float_mask_cst_lvl(PLAIN plain, float input, size_t len,
                                    SCALE_T scale, int level);
void Seal_encode_double_mask_cst_lvl(PLAIN plain, double input, size_t len,
                                     SCALE_T scale, int level);
double* Seal_handle_output(const char* name);

//! @brief Seal API for evaluation
void Seal_add_ciph(CIPHER res, CIPHER op1, CIPHER op2);
void Seal_add_plain(CIPHER res, CIPHER op1, PLAIN op2);
void Seal_mul_ciph(CIPHER res, CIPHER op1, CIPHER op2);
void Seal_mul_plain(CIPHER res, CIPHER op1, PLAIN op2);
void Seal_rotate(CIPHER res, CIPHER op, int step);
void Seal_rescale(CIPHER res, CIPHER op);
void Seal_mod_switch(CIPHER res, CIPHER op);
void Seal_relin(CIPHER res, CIPHER3 op);
void Seal_copy(CIPHER res, CIPHER op);
void Seal_zero(CIPHER res);

#ifdef SEAL_BTS_MACRO
void Seal_bootstrap(CIPHER res, CIPHER op, int level);
#endif
//! @brief Return whether bts is required
//! generated by fhe-cmplr
bool Need_bts();

SCALE_T Seal_scale(CIPHER res);
LEVEL_T Seal_level(CIPHER res);

#ifdef __cplusplus
}
#endif

#endif  // RTLIB_RT_SEAL_SEAL_API_H
