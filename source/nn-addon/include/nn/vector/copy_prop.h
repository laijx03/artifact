//-*-c++-*-
//=============================================================================
//
// Copyright (c) XXXX-XXXX., Ltd
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//=============================================================================

#ifndef NN_VECTOR_COPY_PROP_CTX_H
#define NN_VECTOR_COPY_PROP_CTX_H

#include "air/base/analyze_ctx.h"
#include "air/core/default_handler.h"
#include "air/opt/ssa_build.h"
#include "air/opt/ssa_container.h"
#include "nn/vector/config.h"
#include "nn/vector/vector_ctx.h"
#include "nn/vector/vector_enum.h"
#include "nn/vector/vector_utils.h"

namespace nn {

namespace vector {

using namespace air::base;
using namespace air::driver;

using SSA_VER_ID       = air::opt::SSA_VER_ID;
using DEF_SYM_NODE_VEC = std::vector<NODE_PTR>;

class COPY_PROP_CTX : public ANALYZE_CTX {
public:
  COPY_PROP_CTX(FUNC_SCOPE* func_cope, VECTOR_CTX& ctx,
                const DRIVER_CTX* driver_ctx, const VECTOR_CONFIG& cfg)
      : _ctx(ctx),
        _driver_ctx(driver_ctx),
        _config(cfg),
        _ssa_cntr(&func_cope->Container()),
        _ssa_builder(func_cope, &_ssa_cntr, driver_ctx),
        _def_sym_node_vec() {}

  // declare access API for VECTOR_CTX
  DECLARE_VECTOR_CTX_ACCESS_API(_ctx)

  // declare access API for VECTOR_CONFIG
  DECLARE_VECTOR_CONFIG_ACCESS_API(_config)

  // declare trace API for detail tracing
  DECLARE_TRACE_DETAIL_API(_config, _driver_ctx)

  DEF_SYM_NODE_VEC& Get_def_sym_node_vec() { return _def_sym_node_vec; }

  void Insert_def_sym_node_vec(NODE_PTR def_sym_node) {
    _def_sym_node_vec.push_back(def_sym_node);
  }

  void Build_ssa() { _ssa_builder.Perform(); }

  air::opt::SSA_CONTAINER* Ssa_cntr() { return &_ssa_cntr; }

  //! @brief judge whether this op is the boundary op of constant folding.
  //! Conv, gemm and strided_slice(whose input is generated by conv) are
  //! boundary ops till now. These ops partition the region of constant folding
  //! which can make later constant folding effecient.
  bool Is_cf_boundary_op(NODE_PTR node) {
    if ((node->Opcode() == OPCODE(nn::core::NN, nn::core::OPCODE::CONV)) ||
        (node->Opcode() == OPCODE(nn::core::NN, nn::core::OPCODE::GEMM))) {
      return true;
    }

    // if the input of strided_slice node is generated by conv, then this
    // strided_slice node is also a boundary op.
    if (node->Opcode() ==
        OPCODE(nn::core::NN, nn::core::OPCODE::STRIDED_SLICE)) {
      NODE_PTR ss_input_node = node->Child(0);
      if (ss_input_node->Opcode() ==
          OPCODE(nn::core::NN, nn::core::OPCODE::CONV)) {
        return true;
      } else if ((ss_input_node->Opcode() == air::core::LD) ||
                 (ss_input_node->Opcode() == air::core::LDP)) {
        air::opt::SSA_CONTAINER* ssa_cntr = this->Ssa_cntr();
        air::opt::SSA_VER_PTR ssa_ver = ssa_cntr->Node_ver(ss_input_node->Id());
        AIR_ASSERT_MSG(ssa_ver->Kind() == air::opt::VER_DEF_KIND::STMT,
                       "must define by stmt");

        CONTAINER* cntr            = ssa_cntr->Container();
        NODE_PTR ss_input_def_node = cntr->Stmt(ssa_ver->Def_stmt_id())->Node();
        if (ss_input_def_node->Child(0)->Opcode() ==
            OPCODE(nn::core::NN, nn::core::OPCODE::CONV)) {
          return true;
        }
      }
    }
    return false;
  }

  //! @brief Partial copy propation for later constant folding.
  //! Only do copy propagation for ops which do not belong to constant folding
  //! boundary ops.
  void Partial_copy_prop(NODE_PTR node) {
    air::opt::SSA_CONTAINER* ssa_cntr = this->Ssa_cntr();
    air::opt::SSA_VER_PTR    ssa_ver  = ssa_cntr->Node_ver(node->Id());
    AIR_ASSERT_MSG(ssa_ver->Kind() == air::opt::VER_DEF_KIND::STMT,
                   "must define by stmt");

    CONTAINER* cntr     = ssa_cntr->Container();
    NODE_PTR   def_node = cntr->Stmt(ssa_ver->Def_stmt_id())->Node();

    if (!this->Is_cf_boundary_op(def_node->Child(0))) {
      NODE_PTR def_expr = cntr->Clone_node_tree(def_node->Child(0));
      // get the parent node of this ld node.
      NODE_PTR parent_node = this->Parent(1);
      // substitute use with def
      for (uint32_t i = 0; i < parent_node->Num_child(); i++) {
        if (parent_node->Child(i)->Id() == node->Id()) {
          parent_node->Set_child(i, def_expr);
        }
      }
      // record old define node, later will be deleted(DSE)
      DEF_SYM_NODE_VEC def_sym_node_vec = this->Get_def_sym_node_vec();
      if (std::find(def_sym_node_vec.begin(), def_sym_node_vec.end(),
                    def_node) == def_sym_node_vec.end()) {
        this->Insert_def_sym_node_vec(def_node);
      }
    }
  }

  //! @brief delete all dead store node after copy propagation
  void Dead_store_elimination() {
    DEF_SYM_NODE_VEC def_sym_node_vec = this->Get_def_sym_node_vec();
    for (DEF_SYM_NODE_VEC::iterator it = def_sym_node_vec.begin();
         it != def_sym_node_vec.end(); ++it) {
      NODE_PTR  def_node  = *it;
      STMT_LIST stmt_list = STMT_LIST::Enclosing_list(def_node->Stmt());
      stmt_list.Remove(def_node->Stmt());
    }
  }

private:
  VECTOR_CTX&             _ctx;
  const DRIVER_CTX*       _driver_ctx;
  const VECTOR_CONFIG&    _config;
  air::opt::SSA_CONTAINER _ssa_cntr;
  air::opt::SSA_BUILDER   _ssa_builder;
  DEF_SYM_NODE_VEC        _def_sym_node_vec;
};

//! @brief CORE handler
class COPY_PROP_CORE_HANDLER : public air::core::DEFAULT_HANDLER {
public:
  template <typename RETV, typename VISITOR>
  RETV Handle_st(VISITOR* visitor, air::base::NODE_PTR node) {
    visitor->template Visit<RETV>(node->Child(0));
    return RETV();
  }

  template <typename RETV, typename VISITOR>
  RETV Handle_stp(VISITOR* visitor, air::base::NODE_PTR node) {
    return Handle_st<RETV, VISITOR>(visitor, node);
  }

  template <typename RETV, typename VISITOR>
  RETV Handle_ld(VISITOR* visitor, air::base::NODE_PTR node) {
    // input is the parameter of the function, do not process ld "input" here.
    if (!node->Has_sym() ||
        (strncmp(node->Addr_datum()->Name()->Char_str(), "input", 5) != 0)) {
      visitor->Context().Partial_copy_prop(node);
    }
    return RETV();
  }

  template <typename RETV, typename VISITOR>
  RETV Handle_ldp(VISITOR* visitor, air::base::NODE_PTR node) {
    return Handle_ld<RETV, VISITOR>(visitor, node);
  }

  template <typename RETV, typename VISITOR>
  RETV Handle_retv(VISITOR* visitor, air::base::NODE_PTR node) {
    AIR_ASSERT_MSG(node->Num_child() == 1, "retv should only contains 1 child");
    COPY_PROP_CTX& ctx = visitor->Context();
    ctx.Dead_store_elimination();
    return RETV();
  }

};  // COPY_PROP_CORE_HANDLER

}  // namespace vector

}  // namespace nn

#endif  // NN_VECTOR_COPY_PROP_CTX_H
